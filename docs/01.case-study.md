# Subtitle Converter Design & Implementation Plan

Below is a **detailed design and implementation plan** for a local **subtitle converter** written in **Node.js + TypeScript** named **SubZilla**. We’ll be mindful of **SOLID**, **YAGNI**, **KISS**, and **DRY** principles—**focusing on a clear structure without over-engineering**.

## 1. High-Level Overview

1.  **Purpose**
    - Convert subtitle files (`.srt`, `.sub`, `.txt`) to **UTF-8** with proper Arabic (or other language) support.
2.  **Core Tasks**
    1.  **Detect** the current file encoding.
    2.  **Convert** the file content to UTF-8.
    3.  **Save** the converted file.
3.  **Tools & Libraries**
    - **TypeScript** for typed JavaScript.
    - **Node.js FS** module for reading/writing files.
    - **chardet** (or `jschardet`) to detect encoding.
    - **iconv-lite** to convert the text to UTF-8.
    - **Inquirer** (or `commander`) for a CLI (if we want interactive command-line usage).

We’re **keeping it simple** by focusing on the essentials: reading a file, detecting encoding, converting, and saving.

## 2. Directory Structure

A typical, minimal Node.js + TypeScript layout might look like:

```
subzilla/
├── package.json
├── tsconfig.json
├── .gitignore
├── src
│   ├── cli
│   │   └── main.ts
│   ├── core
│   │   ├── SubtitleProcessor.ts
│   │   ├── EncodingDetectionService.ts
│   │   ├── EncodingConversionService.ts
│   │   └── index.ts
│   ├── utils
│   │   └── FileUtils.ts
│   └── types
│       └── index.d.ts      // or separate definition files if needed
└── test
    ├── SubtitleProcessor.spec.ts
    └── ...
```

### Folder & File Responsibilities

1.  **`src/cli/`**
    - **`main.ts`**: CLI entry point. Handles user input, calls `SubtitleProcessor` for actual work.
2.  **`src/core/`**
    - **`SubtitleProcessor.ts`**:
      - High-level façade for reading input files, detecting encoding, converting, and writing output.
    - **`EncodingDetectionService.ts`**:
      - Responsible for detecting file encoding (using `chardet` or `jschardet`).
    - **`EncodingConversionService.ts`**:
      - Responsible for converting text from a given encoding to UTF-8 (using `iconv-lite`).
    - **`index.ts`**:
      - Exports the core services (for easier imports).
3.  **`src/utils/`**
    - **`FileUtils.ts`**:
      - Helper functions for reading and writing files, building file paths, etc.
4.  **`src/types/`** (Optional)
    - Contains any custom type definitions or interfaces if needed.
5.  **`test/`**
    - Contains unit and integration tests.
    - Example: **`SubtitleProcessor.spec.ts`** for testing the main logic.

## 3. Class & Service Design

### 3.1 **`EncodingDetectionService`**

- **Single Responsibility (SRP)**: Only deals with detecting the file’s current encoding.
- **Interface**:
  ```ts
  import fs from "fs";
  import chardet from "chardet";

  export class EncodingDetectionService {
    public static detectEncoding(filePath: string): Promise<string> {
      return new Promise((resolve, reject) => {
        fs.readFile(filePath, (err, data) => {
          if (err) {
            return reject(err);
          }

          const encoding = chardet.detect(data);

          // If `chardet` returns null, fallback to something like 'utf-8'
          resolve(encoding || "utf-8");
        });
      });
    }
  }
  ```
  - We use a static method for simplicity, but you could also create an instance-based service if you prefer.

### 3.2 `EncodingConversionService`

- **Single Responsibility**: Convert text from one encoding to UTF-8.
- **Interface**:
  ```ts
  import iconv from "iconv-lite";

  export class EncodingConversionService {
    public static convertToUtf8(
      content: Buffer,
      originalEncoding: string
    ): string {
      // Convert from original encoding to a UTF-8 string
      return iconv.decode(content, originalEncoding);
    }
  }
  ```
  - We rely on `iconv-lite`’s `decode()` to get a UTF-8 string.

### 3.3 `SubtitleProcessor`

- Acts as the **facade/orchestrator** for the entire flow:
  1.  Detect the file encoding.
  2.  Convert the content to UTF-8.
  3.  Write the output to disk.
- **Interface**:
  ```ts
  import fs from "fs/promises";
  import { EncodingDetectionService } from "./EncodingDetectionService";
  import { EncodingConversionService } from "./EncodingConversionService";

  export class SubtitleProcessor {
    public async processFile(
      inputFilePath: string,
      outputFilePath?: string
    ): Promise<void> {
      // 1. Detect encoding
      const detectedEncoding = await EncodingDetectionService.detectEncoding(
        inputFilePath
      );

      // 2. Read file as Buffer
      const fileBuffer = await fs.readFile(inputFilePath);

      // 3. Convert to UTF-8
      const utf8Content = EncodingConversionService.convertToUtf8(
        fileBuffer,
        detectedEncoding
      );

      // 4. Determine output path
      const finalOutputPath =
        outputFilePath || this.getDefaultOutputPath(inputFilePath);

      // 5. Write file as UTF-8
      await fs.writeFile(finalOutputPath, utf8Content, { encoding: "utf8" });
    }

    private getDefaultOutputPath(inputFilePath: string): string {
      // Example logic: 'example.srt' -> 'example.utf8.srt'
      const dotIndex = inputFilePath.lastIndexOf(".");

      if (dotIndex === -1) {
        return `${inputFilePath}.utf8`;
      }

      const baseName = inputFilePath.substring(0, dotIndex);
      const extension = inputFilePath.substring(dotIndex);

      return `${baseName}.utf8${extension}`;
    }
  }
  ```

## 4. CLI Implementation

### 4.1 `src/cli/main.ts`

If we want a **command-line** interface using **`inquirer`** or **`commander`**, we can keep it minimal. Below is an example using `commander`:

```ts
#!/usr/bin/env node

import { Command } from "commander";
import { SubtitleProcessor } from "../core/SubtitleProcessor";

const program = new Command();
const processor = new SubtitleProcessor();

program
  .name("subtitle-converter")
  .description("Convert subtitle files to UTF-8")
  .version("1.0.0");

program
  .command("convert <inputFilePath> [outputFilePath]")
  .description("Convert a subtitle file to UTF-8")
  .action(async (inputFilePath: string, outputFilePath?: string) => {
    try {
      await processor.processFile(inputFilePath, outputFilePath);
      console.log("Conversion successful!");
    } catch (error) {
      console.error("Error:", error);
    }
  });

program.parse(process.argv);
```

1.  **`convert <inputFilePath> [outputFilePath]`** – We specify the required input file and optional output file.
2.  We create a new `SubtitleProcessor` and call `processFile(...)`.

_Make sure to give this file execution permissions on Unix systems (`chmod +x src/cli/main.ts`)._

## 5. Testing

### 5.1 Example Test: `SubtitleProcessor.spec.ts`

```ts
import { expect } from "chai";
import fs from "fs/promises";
import { SubtitleProcessor } from "../src/core/SubtitleProcessor";

describe("SubtitleProcessor", () => {
  it("should convert a file to UTF-8", async () => {
    const processor = new SubtitleProcessor();
    const testFile = "test-resources/sample-arabic.srt";
    const outputFile = "test-resources/sample-arabic.utf8.srt";

    // Cleanup if file exists
    try {
      await fs.unlink(outputFile);
    } catch (_) {}

    await processor.processFile(testFile, outputFile);

    const convertedContent = await fs.readFile(outputFile, {
      encoding: "utf8",
    });

    // Basic check: verify if content is readable in UTF-8
    expect(convertedContent).to.include("بسم الله الرحمن الرحيم"); // Arabic text you expect
  });
});
```

## 6. Linting

1. **[ESLint](https://eslint.org/)**
   - A popular linting tool for JavaScript/TypeScript.
2. **[@typescript-eslint/eslint-plugin](https://github.com/typescript-eslint/typescript-eslint)**
   - Bridges the gap between ESLint and TypeScript, providing rules specific to TypeScript.
3. **[@typescript-eslint/parser](https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/parser)**
   - Allows ESLint to parse TypeScript files.
4. **[Prettier](https://prettier.io/)** (Optional, but highly recommended)
   - Opinionated code formatter that can integrate with ESLint.

### Add Lint Scripts to `package.json`

In our `package.json`, you might add:

```json
{
  "scripts": {
    "lint": "eslint 'src/**/*.{ts,tsx}'",
    "lint:fix": "eslint 'src/**/*.{ts,tsx}' --fix"
  }
}
```

### Integrate Prettier

- Create **`.prettierrc`** or **`.prettierrc.js`**:
  ```json
  {
    "singleQuote": true,
    "semi": true,
    "trailingComma": "all",
    "indent": 4
  }
  ```

## 7. Logging, Edge Cases & Error Handling

### 1. Logging

Provide **minimal but useful** logs for debugging without cluttering the console.

- Use `console.log` for basic CLI messages.
- Use a logging library like [`winston`](https://github.com/winstonjs/winston) for structured logging.
- Use different log levels (`info`, `warn`, `error`) for different types of messages.
- Use relevant emojis for messages.

### 2. Edge Cases & Error Handling

Gracefully handle errors without crashing the app.

#### Edge Cases & Solutions

| Edge Case                                  | Handling Strategy                                           |
| ------------------------------------------ | ----------------------------------------------------------- |
| **File doesn’t exist**                     | Check existence before processing, return an error message. |
| **Unreadable file (corrupt/empty)**        | Detect and skip, logging a warning.                         |
| **Unsupported encoding**                   | Fallback to UTF-8 and notify the user.                      |
| **No subtitle files found in a directory** | Return a meaningful message instead of failing silently.    |
| **Output file exists (overwrite issue)**   | Ask for confirmation or append `.converted` suffix.         |
| **Invalid file format (e.g., `.pdf`)**     | Validate file extensions before processing.                 |
| **Permissions issue (cannot read/write)**  | Catch `EACCES` errors and inform the user.                  |

## 8. Further Enhancements

1.  **Batch Processing**
    - Extend `processFile(...)` to `processFiles([...])` or a new `processDirectory(...)`.
2.  **Recursive Directory Processing**
    - Allow the user to **point to a directory** instead of an individual file. The app will recursively **find** all subtitle files (e.g., `.srt`, `.sub`, `.txt`) in that directory and **process** them automatically.
3.  **Stripping Coloring/HTML/Rich Formatting**
    - Some subtitle files contain **color tags** or **HTML-like formatting** (e.g., `<font color="#FF0000">`, `<b>`, `<i>`, etc.). We want an option to **remove** these tags so that the final text is plain.
4.  **GUI**
    - Add an Electron-based or web-based (Express + React/Vue) interface.
5.  **Configuration File**
    - YAML/JSON-based config to specify custom output paths, logging preferences, etc.
