---
alwaysApply: true
description: Coding standards, best practices, and design principles for SubZilla
---

# Coding Standards & Best Practices üéØ

SubZilla follows **SOLID, YAGNI, KISS, and DRY** principles with a focus on **simplicity, clarity, and completeness**.

## üèóÔ∏è Design Principles

### SOLID Principles

- **Single Responsibility**: Each class has one clear purpose

    ```typescript
    // ‚úÖ Good - focused responsibility
    class EncodingDetectionService {
        public detectEncoding(buffer: Buffer): string {}
    }

    // ‚ùå Bad - multiple responsibilities
    class FileProcessor {
        public detectEncoding() {}
        public convertEncoding() {}
        public stripFormatting() {}
        public createBackup() {}
    }
    ```

- **Open/Closed**: Extensible through interfaces

    ```typescript
    // ‚úÖ Good - extensible strategy pattern
    interface IOutputStrategy {
        getOutputPath(inputPath: string): string;
        shouldBackup: boolean;
    }

    class SuffixOutputStrategy implements IOutputStrategy {}
    class OverwriteOutputStrategy implements IOutputStrategy {}
    ```

- **Dependency Inversion**: Depend on abstractions

    ```typescript
    // ‚úÖ Good - depends on interface
    class SubtitleProcessor {
        constructor(private outputStrategy: IOutputStrategy) {}
    }

    // ‚ùå Bad - depends on concrete class
    class SubtitleProcessor {
        private strategy = new SuffixOutputStrategy();
    }
    ```

### YAGNI (You Aren't Gonna Need It)

- **Build only what's needed** for current requirements
- **Avoid over-engineering** and speculative features
- **Refactor when requirements change**, not before

### KISS (Keep It Simple, Stupid)

- **Prioritize simplicity** over cleverness
- **Use clear, descriptive names**
- **Prefer explicit over implicit** behavior
- **Minimize cognitive load**

### DRY (Don't Repeat Yourself)

- **Share common code** in appropriate packages
- **Use configuration** instead of hardcoding
- **Extract reusable utilities**

## üìù Code Quality Standards

### Comments & Documentation

- **Don't delete comments** - refine them if necessary
- **Include detailed comments** when necessary
- **Write self-documenting code** where possible
- **Use JSDoc** for public APIs

````typescript
/**
 * üîÑ Processes subtitle files with encoding conversion and formatting options
 *
 * @param inputFilePath - Path to the input subtitle file
 * @param options - Processing options including output path and strip settings
 * @returns Promise resolving to output and backup paths
 *
 * @example
 * ```typescript
 * const result = await processor.processFile('input.srt', {
 *     stripOptions: { html: true, colors: true }
 * });
 * ```
 */
public async processFile(
    inputFilePath: string,
    options: IConvertOptions = {}
): Promise<{ outputPath: string; backupPath?: string }> {
    // Validate input file exists
    await fs.access(inputFilePath);

    // Process with clear steps...
}
````

### Error Handling

- **Provide complete implementations** rather than skeleton code
- **Handle errors gracefully** with meaningful messages
- **Use emojis** in logging for better UX
- **Include context** in error messages

```typescript
// ‚úÖ Good - comprehensive error handling
try {
    const result = await this.processFile(filePath, options);
    console.log(`‚úÖ Successfully processed: ${filePath}`);
    return result;
} catch (error) {
    const message = `‚ùå Failed to process ${filePath}: ${(error as Error).message}`;
    console.error(message);

    // Add to batch statistics for reporting
    this.stats.errors.push({
        file: filePath,
        error: message,
        timestamp: new Date().toISOString(),
    });

    // Decide whether to continue or fail fast
    if (options.failFast) {
        throw new Error(`Batch processing stopped: ${message}`);
    }

    return null;
}
```

### Logging with Emojis

- **Use relevant emojis** for visual feedback
- **Be consistent** with emoji usage
- **Provide clear status** indicators

```typescript
// ‚úÖ Good - emoji-rich logging
console.log('üîç Detecting file encoding...');
console.log('üîÑ Converting to UTF-8...');
console.log('‚ú® Stripping HTML formatting...');
console.log('üíæ Creating backup...');
console.log('‚úÖ Processing complete!');

// Error states
console.warn('‚ö†Ô∏è  Warning: Backup already exists');
console.error('‚ùå Failed to detect encoding');
console.info('‚ÑπÔ∏è  Skipping existing UTF-8 file');
```

## üé® Code Style Guidelines

### Function Design

- **Keep functions focused** on single tasks
- **Limit parameter count** (max 3-4 parameters)
- **Use options objects** for complex parameters
- **Return meaningful values**

```typescript
// ‚úÖ Good - focused function with options object
public async convertFile(
    inputPath: string,
    options: IConvertOptions = {}
): Promise<IConvertResult> {
    const {
        outputPath,
        createBackup = false,
        stripOptions = {},
        encoding = 'auto'
    } = options;

    // Clear implementation steps...
}

// ‚ùå Bad - too many parameters
public async convertFile(
    inputPath: string,
    outputPath?: string,
    createBackup?: boolean,
    stripHtml?: boolean,
    stripColors?: boolean,
    encoding?: string,
    overwrite?: boolean
): Promise<string> { }
```

### Variable Naming

- **Use descriptive names** that explain purpose
- **Avoid abbreviations** unless universally understood
- **Be consistent** with naming patterns

```typescript
// ‚úÖ Good - clear, descriptive names
const inputFilePath = path.resolve(inputFile);
const shouldCreateBackup = options.createBackup ?? false;
const detectedEncoding = await this.encodingService.detect(buffer);
const convertedContent = await this.encodingService.convert(content, 'utf8');

// ‚ùå Bad - unclear abbreviations
const inp = path.resolve(f);
const bkp = opts.cb ?? false;
const enc = await this.svc.det(buf);
```

### Method Organization

```typescript
export default class ExampleService {
    // 1. Constants and static properties
    private static readonly DEFAULT_ENCODING = 'utf8';
    private static readonly SUPPORTED_FORMATS = ['.srt', '.sub', '.txt'];

    // 2. Instance properties
    private config: IConfig;
    private dependencies: IDependencies;

    // 3. Constructor
    constructor(config?: IConfig) {
        this.config = { ...DEFAULT_CONFIG, ...config };
        this.initializeDependencies();
    }

    // 4. Public interface methods (main functionality)
    public async processFile(path: string): Promise<IResult> {
        // Main business logic
    }

    public async processBatch(pattern: string): Promise<IBatchResult> {
        // Batch processing logic
    }

    // 5. Private helper methods
    private async validateInput(path: string): Promise<void> {
        // Input validation
    }

    private initializeDependencies(): void {
        // Setup internal state
    }
}
```

## üöÄ Performance Guidelines

### Async Operations

- **Use async/await** consistently
- **Handle concurrent operations** with Promise.all
- **Avoid blocking the event loop**

```typescript
// ‚úÖ Good - parallel processing
const results = await Promise.all(
    files.map(async (file) => {
        try {
            return await this.processFile(file, options);
        } catch (error) {
            return { file, error: (error as Error).message };
        }
    })
);

// ‚ùå Bad - sequential processing
const results = [];
for (const file of files) {
    try {
        const result = await this.processFile(file, options);
        results.push(result);
    } catch (error) {
        results.push({ file, error: (error as Error).message });
    }
}
```

### Memory Management

- **Stream large files** when possible
- **Clean up resources** properly
- **Use appropriate data structures**

```typescript
// ‚úÖ Good - streaming for large files
import { createReadStream, createWriteStream } from 'fs';

public async processLargeFile(inputPath: string, outputPath: string): Promise<void> {
    const readStream = createReadStream(inputPath);
    const writeStream = createWriteStream(outputPath);

    try {
        // Process stream in chunks
        for await (const chunk of readStream) {
            const processedChunk = this.processChunk(chunk);
            writeStream.write(processedChunk);
        }
    } finally {
        readStream.destroy();
        writeStream.end();
    }
}
```

### Configuration Management

- **Use configuration objects** instead of multiple parameters
- **Provide sensible defaults**
- **Support multiple configuration sources**

```typescript
// ‚úÖ Good - comprehensive configuration
const DEFAULT_CONFIG: IConfig = {
    input: {
        encoding: 'auto',
        format: 'auto',
    },
    output: {
        directory: './converted',
        createBackup: false,
        overwriteBackup: true,
        format: 'srt',
        encoding: 'utf8',
    },
    strip: {
        html: false,
        colors: false,
        styles: false,
    },
};

// Merge user config with defaults
const config = this.mergeConfigs(DEFAULT_CONFIG, userConfig, envConfig);
```

## üîß Development Practices

### Testing Approach

- **Write tests for core functionality**
- **Test error conditions**
- **Use descriptive test names**
- **Mock external dependencies**

### Code Reviews

- **Check adherence to principles** (SOLID, YAGNI, KISS, DRY)
- **Verify error handling** is comprehensive
- **Ensure code is self-documenting**
- **Validate performance considerations**

### Refactoring Guidelines

- **Extract common patterns** into utilities
- **Simplify complex functions**
- **Improve naming** for clarity
- **Add missing error handling**

## üìã Quality Checklist

Before submitting code, ensure:

- [ ] **Follows SOLID principles**
- [ ] **Implements complete functionality** (no skeleton code)
- [ ] **Includes proper error handling**
- [ ] **Uses descriptive names** and comments
- [ ] **Handles edge cases** appropriately
- [ ] **Follows TypeScript conventions**
- [ ] **Includes emoji logging** where appropriate
- [ ] **Maintains performance** considerations
- [ ] **Adheres to package boundaries**
- [ ] **Builds successfully** across all packages

## üéØ Code Review Focus Areas

### Architecture

- Does the code follow the established patterns?
- Are dependencies properly managed?
- Is the separation of concerns clear?

### Implementation

- Is the code complete and production-ready?
- Are error cases handled comprehensively?
- Is the performance acceptable?

### Maintainability

- Is the code easy to understand and modify?
- Are the abstractions appropriate?
- Is the documentation sufficient?

Remember: **Fewer lines of code is better**, but not at the expense of clarity or completeness. Aim for **robust, production-ready implementations** that follow established patterns and principles.
