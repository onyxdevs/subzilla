---
alwaysApply: true
description: Development workflow, testing patterns, and tooling for SubZilla
---

# Development Workflow & Testing üîß

Comprehensive guide for SubZilla development workflow, testing patterns, and tooling setup.

## üöÄ Development Setup

### Initial Setup

```bash
# Clone and setup
git clone https://github.com/onyxdevs/subzilla.git
cd subzilla

# Install dependencies (installs all workspace packages)
yarn install

# Build all packages
yarn build

# Start development mode
yarn dev
```

### Development Environment

- **Node.js**: v14 or higher
- **Yarn**: Package manager (no PnP)
- **TypeScript**: v5.9.2+
- **ESLint**: Code linting
- **Prettier**: Code formatting

## üîÑ Development Workflow

### Daily Development

```bash
# Start development mode (watches all packages)
yarn dev

# In another terminal, test changes
yarn start convert --help
yarn start batch "*.srt" --help

# Build specific package during development
yarn workspace @subzilla/core build
yarn workspace @subzilla/cli build
```

### Making Changes

#### 1. Feature Development Process

```bash
# 1. Create feature branch
git checkout -b feature/amazing-feature

# 2. Start development mode
yarn dev

# 3. Make changes following the established patterns
# 4. Test changes continuously
yarn start convert test.srt --strip-all

# 5. Build and validate
yarn build
yarn type-check
yarn lint
```

#### 2. Adding New Features

1. **Define interfaces** in `@subzilla/types` first
2. **Implement core logic** in `@subzilla/core`
3. **Add CLI interface** in `@subzilla/cli`
4. **Test across packages**

#### 3. Cross-Package Changes

```bash
# When changing types that affect multiple packages
yarn workspace @subzilla/types build
yarn workspace @subzilla/core build
yarn workspace @subzilla/cli build

# Or use project references (recommended)
yarn build  # Builds in dependency order
```

## üß™ Testing Strategy

### Current Testing Setup

```bash
# Run tests across all packages
yarn test

# Test specific package
yarn workspace @subzilla/core test
yarn workspace @subzilla/cli test
```

### Jest Testing Framework

SubZilla uses **Jest** with **TypeScript** for comprehensive testing across all packages. The testing framework was chosen specifically for **Electron compatibility** and provides robust mocking capabilities.

#### Test Configuration

- **Multi-project Jest setup** with TypeScript support
- **Package-specific configurations** with proper module resolution
- **Shared test fixtures** in `__tests__/fixtures/`
- **CI/CD integration** with GitHub Actions

#### Current Test Coverage

```bash
# Run all tests across packages
yarn test

# Results: 83 tests passing across 7 test suites
Test Suites: 7 passed, 7 total
Tests:       83 passed, 83 total
```

#### Test Structure by Package

**@subzilla/types** (13 tests):

- Zod schema validation for configuration
- Strip options validation
- Type safety verification

**@subzilla/core** (57 tests):

- `EncodingDetectionService`: UTF-8, Windows-1256, binary handling
- `EncodingConversionService`: Multi-encoding conversion
- `FormattingStripper`: HTML, colors, styles, emojis removal
- `SubtitleProcessor`: End-to-end integration tests

**@subzilla/cli** (13 tests):

- Command registration and help text
- CLI option parsing and validation
- Error handling and graceful degradation
- Mock-based testing with proper TypeScript types

#### Key Testing Patterns

**Unit Tests with Proper Setup:**

```typescript
describe('EncodingDetectionService', () => {
    let service: EncodingDetectionService;

    beforeEach(() => {
        service = new EncodingDetectionService();
    });

    it('should detect Windows-1256 for Arabic content', async () => {
        const arabicText = 'ŸÖÿ±ÿ≠ÿ®ÿß ÿ®ÿßŸÑÿπÿßŸÑŸÖ';
        const buffer = Buffer.from(arabicText, 'windows1256');
        const encoding = await service.detectEncoding(buffer);
        expect(encoding).toBe('windows1256');
    });
});
```

**Integration Tests with Temp Files:**

```typescript
describe('SubtitleProcessor Integration', () => {
    let processor: SubtitleProcessor;
    let tempDir: string;

    beforeEach(async () => {
        processor = new SubtitleProcessor();
        tempDir = await fs.promises.mkdtemp(path.join(os.tmpdir(), 'subzilla-test-'));
    });

    afterEach(async () => {
        await fs.promises.rm(tempDir, { recursive: true, force: true });
    });

    it('should process Arabic subtitle file end-to-end', async () => {
        const inputPath = path.join(tempDir, 'arabic.srt');
        const arabicContent = '1\n00:00:01,000 --> 00:00:03,000\nŸÖÿ±ÿ≠ÿ®ÿß ÿ®ÿßŸÑÿπÿßŸÑŸÖ';
        await fs.promises.writeFile(inputPath, arabicContent, 'windows1256');

        const result = await processor.processFile(inputPath, {
            stripOptions: { html: true },
        });

        expect(result.outputPath).toContain('.subzilla.srt');
        const outputContent = await fs.promises.readFile(result.outputPath, 'utf8');
        expect(outputContent).toContain('ŸÖÿ±ÿ≠ÿ®ÿß ÿ®ÿßŸÑÿπÿßŸÑŸÖ');
    });
});
```

**CLI Tests with TypeScript Mocks:**

```typescript
// Proper TypeScript mock typing to avoid 'never' type issues
const mockProcessFile = jest.fn<() => Promise<{ outputPath: string }>>().mockResolvedValue({
    outputPath: '/mock/output.srt',
});

describe('CLI Commands', () => {
    it('should execute convert command successfully', async () => {
        const output = execSync('node dist/main.js convert --help', { encoding: 'utf8' });
        expect(output).toContain('Convert a single subtitle file to UTF-8');
    });
});
```

#### Test Fixtures

Shared test data in `__tests__/fixtures/`:

- `sample.srt`: Basic SRT file for testing
- `arabic.srt`: Arabic content with Windows-1256 encoding
- `empty.srt`: Empty file edge case testing

#### Critical Testing Insights

1. **TypeScript + Jest Mocking**: Use explicit generic types `jest.fn<() => Promise<ReturnType>>()` to avoid `never` type inference
2. **Module Resolution**: Use `moduleNameMapper` (not `moduleNameMapping`) for workspace package resolution
3. **Async Testing**: Proper cleanup with `beforeEach`/`afterEach` for temp files and mocks
4. **Real CLI Testing**: Use `execSync` for actual CLI command validation

## üîç Quality Assurance

### Code Quality Tools

#### ESLint Configuration ([eslint.config.js](mdc:eslint.config.js))

```bash
# Run linting
yarn lint

# Fix linting issues
yarn lint:fix

# Lint specific package
yarn workspace @subzilla/core lint
```

#### TypeScript Type Checking

```bash
# Type check all packages
yarn type-check

# Type check specific package
yarn workspace @subzilla/types type-check
```

#### Prettier Formatting

```bash
# Format all code
yarn format

# Check formatting
yarn format:check

# Format specific files
yarn prettify
```

### Pre-commit Workflow

```bash
# Before committing, run full quality check
yarn build      # Ensure everything builds
yarn type-check # Validate types
yarn lint       # Check code quality
yarn format     # Ensure consistent formatting
yarn test       # Run test suite (when implemented)
```

## üêõ Debugging & Troubleshooting

### Common Development Issues

#### Build Errors

```bash
# Clean and rebuild
yarn clean
yarn build

# Check TypeScript project references
tsc --build --dry

# Rebuild specific package
yarn workspace @subzilla/core build
```

#### Type Errors

```bash
# Check cross-package type resolution
yarn workspace @subzilla/cli type-check

# Verify workspace dependencies
yarn workspaces list
```

#### Runtime Issues

```bash
# Test CLI with verbose output
yarn start convert test.srt --verbose

# Debug specific functionality
node -e "
const { SubtitleProcessor } = require('./packages/core/dist');
const processor = new SubtitleProcessor();
// Debug code here
"
```

### Debugging Techniques

#### Console Debugging

```typescript
// Use emoji logging for visual debugging
console.log('üîç Debug: Processing file:', filePath);
console.log('üìä Debug: Options:', JSON.stringify(options, null, 2));
console.log('‚ö° Debug: Performance timing:', Date.now() - startTime, 'ms');
```

#### Error Investigation

```typescript
// Comprehensive error logging
try {
    await this.processFile(filePath, options);
} catch (error) {
    console.error('‚ùå Error details:', {
        file: filePath,
        error: (error as Error).message,
        stack: (error as Error).stack,
        options: JSON.stringify(options),
        timestamp: new Date().toISOString(),
    });
    throw error;
}
```

## üì¶ Package Development

### Adding New Packages

```bash
# Create new package directory
mkdir packages/new-package
cd packages/new-package

# Initialize package.json
yarn init

# Add to workspace (automatic with yarn workspaces)
# Update root tsconfig.json references
```

### Package Development Workflow

```typescript
// 1. Define types in @subzilla/types
export interface INewFeature {
    option: string;
    enabled: boolean;
}

// 2. Implement in @subzilla/core
export default class NewFeatureService {
    public async processFeature(options: INewFeature): Promise<void> {
        // Implementation
    }
}

// 3. Add CLI interface in @subzilla/cli
export default class NewFeatureCommand implements ICommandCreator {
    public create(): ICommandDefinition {
        return {
            name: 'new-feature',
            description: 'Process new feature',
            action: async (options) => {
                const service = new NewFeatureService();
                await service.processFeature(options);
            },
        };
    }
}
```

## üöÄ Performance Monitoring

### Development Performance

```bash
# Monitor build times
time yarn build

# Watch mode performance
yarn dev  # Should have fast incremental rebuilds
```

### Runtime Performance

```typescript
// Performance monitoring in code
const startTime = process.hrtime.bigint();

await this.processFile(filePath, options);

const endTime = process.hrtime.bigint();
const duration = Number(endTime - startTime) / 1_000_000; // Convert to ms

console.log(`‚ö° Processing took ${duration.toFixed(2)}ms`);
```

### Batch Processing Metrics

```typescript
// Built-in performance tracking
const stats = await batchProcessor.processBatch(pattern, options);
console.log(`üìä Processed ${stats.successful} files in ${stats.timeTaken}s`);
console.log(`‚ö° Average: ${stats.averageTimePerFile}s per file`);
```

## üìã Development Checklist

### Before Starting Development

- [ ] **Environment setup** complete (Node.js, Yarn)
- [ ] **Dependencies installed** (`yarn install`)
- [ ] **Initial build** successful (`yarn build`)
- [ ] **Development mode** working (`yarn dev`)

### During Development

- [ ] **Follow established patterns** and conventions
- [ ] **Test changes** continuously with `yarn start`
- [ ] **Check types** with incremental builds
- [ ] **Use emoji logging** for better debugging

### Before Committing

- [ ] **All packages build** successfully (`yarn build`)
- [ ] **Type checking** passes (`yarn type-check`)
- [ ] **Linting** passes (`yarn lint`)
- [ ] **Formatting** is consistent (`yarn format`)
- [ ] **Manual testing** of affected functionality
- [ ] **Cross-package integration** verified

### Code Review Preparation

- [ ] **Clear commit messages** with context
- [ ] **Documentation** updated if needed
- [ ] **Breaking changes** documented
- [ ] **Performance impact** considered

This workflow ensures consistent, high-quality development while maintaining the established patterns and principles of the SubZilla codebase.
